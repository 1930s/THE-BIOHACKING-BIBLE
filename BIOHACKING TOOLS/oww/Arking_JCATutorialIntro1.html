__NOTOC__
==Introduction to Biobricks 2.0==
===What is Biobricks?===
Biobricks is a programming language for Synthetic Biology ('''SB''').  SB means ground-up genetic or cellular Engineering.  We add DNA sequences into well-characterized model organisms to understand biological processes or create useful organisms.  So, we're working principly with E. coli, yeast, human cells, or model plant cells rather than exotic natural isolates.  This restriction on organism allows us develop a shared engineering knowledge.  If you and I both do our experiments in the same strain of E. coli, we can understand each others results, and perhaps combine them into more advanced systems.  The modifications we make to these organisms could be the addition of DNAs or the removal or replacement of DNAs present in the genome.  These latter types of modifications are termed "chassis" modifications.  There is no method yet for standardization of chassis modification.  Biobricks is a standard language for building and describing the DNAs for the former type of modification.

Biobricks begins with defining specific sequences termed '''basic parts'''.  These basic parts are flanked by a standard restriction enzyme-based polylinker in an appropriate plasmid.  So, a Biobrick basic part is a DNA sequence.  It's a conceptual beast, not a physical thing.  A physical plasmid containing the Biobrick sequence is just a plasmid.  In this way, a basic part is much like a word in normal language.  It's a string of letters (A,T,C, or G) whereas English words have 26 letter choices.  Like English words, Biobricks are assembled into larger sentences (called devices) in a linear order.   Basic parts alone rarely confer any activity to a cell just as words alone confer little meaning.  Biobrick basic parts only confer activity in a cell when other appropriate parts flank the part.  Just as English follows a hierarchical organization of letters > words > sentences > paragraphs > books > libraries, Biobricks follow a hierarchy of base pairs > basic parts > composite parts > systems > ecosystems.  The language and relavent descriptions of this hierarchy are still being developed in the SB field, but for now, all DNAs are either basic parts or composite parts.

You can learn more basic information about Biobricks at [http://parts.mit.edu/registry/index.php/Help:Contents The registry]

===Why use Biobricks?===
The reason for doing Biobricks is 3-fold.  First of all, there is a standard assembly method associated with Biobricks.  We'll get into this in the next section, but the general idea is that if everyone uses similar methods of assembly, we open up the possibility that researchers or companies can develop faster, cheaper ways of assembling composite parts.  Secondly, this standardization results in a set of parts that become a shared resource readily usable by the entire biology community.  The third reason is that it rigourously defines the composition of a design which will enable quantitative standardization and descriptions of robustness.  Consider the following figure:<br>
[[Image:JCA_072407fig1.gif|200px]]<br>
This is a typical example of the way sequences of DNA are described throughout the biological disciplines, and there's nothing necessarily ''wrong'' with it.  Consider, though, that someone handed you this map and told you to make something that conferred whatever activity this thing confers.  You see that it has an SV40 origin.  So, maybe you'd pubmed search SV40 and find some annotation of what this thing should be.  Often in doing this, you'll find maybe 10 different sequences all annotated as the SV40 origin.  These labels of function therefore rarely define a unique sequence.  Also, consider that you were going to clone this origin into a plasmid.  Where would you "cut" the sequence?  How many base pairs upstream and downstream of the annotated sequence would you include?  In this case, it might not matter, but when describing features such as promoter and terminator elements this is entirely hazy.  Biobricks resolves this issue.  DNA elements are no longer defined with abstract terms such as SV40 origin, they become a specific Biobrick sequence with an associated number such as J23997.  There may be 100 different SV40 origin-like Biobrick parts, but when you construct an actual plasmid, you pick a specific Biobrick and the composite part you construct can be rigourously defined by the linear sequence of Biobrick parts from which it was made.  This allows us to decifer the basic elements that robustly confer their function in a variety of contexts.  Consider two different (hypothetical) SV40 origin parts J23997 and I13597.  Let's say that J23997 "worked" in 23 out of 50 cases.  Say I13597 woked in 43 our of 50 cases.  Which one would you then choose if you needed to make a composite part with an SV40 origin?  So, basically, this allows us to share parts and also encapsulate information about the use of parts.

===Standard Assembly===
The original version of Biobricks has a polylinker of EcoRI-XbaI-'''Part'''-SpeI-PstI.  SpeI and XbaI have "compatible cohesive ends".  What this means is that when digested, the DNA contains sticky ends of the same sequence, in this case CTAG overhangs.  XbaI-digested fragments can be ligated to SpeI-digested fragments.  When this occurs, both restriction sites are destroyed resulting in an ACTAGA scar sequence.  All methods of standard assembly somehow make thess junctions between two parts.  However, there are multiply protocols being developed to implement the reaction.

===What is Biobricks 2.0?===
Biobricks 2.0 is much like the original, but the polylinker is EcoRI-BglII-'''Part'''-BamHI-XhoI.  The main advantage of this standard is that the scar sequence is GGATCT.  When translated in the zero frame, this becomes Gly-Ser, which is a good linker sequence for peptide fusions.  Biobricks 2.0 can therefore be used for translational fusions.  Additionally, the enzymes in 2.0 digest more efficiently than the 1.0 enzymes and are not blocked by dam methylation.

So, to do Biobricks, the general routine is to make plasmids containing Basic Parts, and then use methods of standard assembly to construct Composite Parts.  The remainder of this tutorial will address the question of how you do these things.
{{Template:JCA_Arkin_tutorialfooter}}